# CourseApp: Assignment 0

## Authors
* Sahar Cohen, 206824088
* Yuval Nahon, 206866832

## Notes

### Implementation Summary
The implementation provides an abstraction of the provided write/read operations for easier high-level use (located in library/storage).
This abstraction (will be referred to as the "database") serves to simulate a convenient file system hierarchy.
The database operates on strings (as both keys and values), utilizes fluent API for easy and intuitive use and is split to four main interfaces:

**Database**: singleton that represents a reference to the *root of the file system*. Used solely for navigating to nested collections.

**CollectionReference**: akin to a *folder* in a file system. Used solely holding documents.

**DocumentReference**: akin to a *file* in a file system. Values are set in a key-value fashion. Terminal operations include: write/read/update/delete etc. Uses a hash table to store the specified key-value pairs to be written in the document.

**ExtendableDocumentReference**: a DocumentReference that can contain its own collections.

Say our **Database** reference singleton is denoted by "db". Usage example of the API:

db.collection("users").document("bob").collection("photos").document("awkward photo").set(data).write()

The database is utilized by the wrapper class **AuthenticationManager**, which provides all the required operations on users in the app. Tokens are generated by chaining the username with the current time (in miliseconds). 

In our design, we've also decided to encrypt document names with the SHA-256 one-way encryption algorithm. Reason for this is that we use the "/" character under the hood to split file paths in the file system. We still want to allow document names to contain this character and avoid collisions, and SHA-256's character set does not use the character.

Deletions in the database are logical deletions. So, when a document / document's field is deleted, we chain a byte array block of "0" to it. Likewise, an "activated" segment is prefixed by a byte array block of "1".

For now, the **CourseAppInitializer** class does nothing.

### Testing Summary
We've decided to write two main tests: one for the database's components and one for CourseApp. We tested the database's components together since they're tied together: you can't do anything useful on a path without a document, and you can't create a document without starting from the root. In both tests, we used MockK to simulate the provided read/write functions: we chose to simulate these calls with a HashMap. Subsequently, after each test we reset the "database" (the hashmap).

Essentially, the CourseApp test actually tests AuthenticationManager because CourseApp's methods are designed to be delegated to this class (this design choice was made with the assumption that CourseApp will need to support more functionallity in the future).

The tests run on JUnit 5.3 and MockK 1.9, and have 100% code coverage.

### Difficulties
We had no prior experience with programming in Kotlin & using MockK so we were pretty clueless at the start. Fortunately, they proved to be very easy and intuitive to use. Our main problem was trying to figure out the database's design. At first, we went with a short and easy API that "did the job", but it felt very "C-style" and low-level (who wants to use enums??), so we scrapped it. Our initial design was prefix-based. When moving on to a better API - we faced the problem of reserved special character "/" in specifying file paths. We decided to used encryption as stated above in order to solve this issue, and made sure to test that it worked. Along the way we got to learn more about Kotlin's standard library.

### Feedback
We think it was a great first assignment to introduce us to the language! Our only complaints are these three:

1) It felt a little too "up in the air" at the start - it wasn't very clear what we were supposed to do and where to start after we read the PDF file. We would really appreciate some stronger guidance at "how to start" in the future, since it's easier once you get into it.

2) We felt it was also a little too long for an introductory assignment.

3) It is stated that we need to support up to 1 million users. However, our mock uses up RAM to emulate the persistent datastore locally. For that reason, we couldn't add more than ~100k users before running out of memory. Playing around with the JVM options did not help solve this. After trying to find a solution for hours, we've decided to leave it as is.
